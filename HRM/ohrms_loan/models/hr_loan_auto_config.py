# -*- coding: utf-8 -*-
from datetime import datetime, timedelta

from dateutil.relativedelta import relativedelta

from odoo import api, fields, models, _
from odoo.exceptions import ValidationError
import xlsxwriter
import base64
from io import BytesIO


class HrLoanAutoConfig(models.Model):
    """Configuration model for automatic loan generation"""
    _name = 'hr.loan.auto.config'
    _description = "Automatic Loan Configuration"
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char(string="Configuration Name", required=True,
                       help="Name of this automatic loan configuration")
    active = fields.Boolean(string="Active", default=True,
                            help="Whether this configuration is active")
    execution_day = fields.Integer(string="Execution Day", required=True,
                                   help="Day of the month when loans will be automatically created",
                                   default=1)
    company_id = fields.Many2one('res.company', string='Company',
                                 help="Company",
                                 default=lambda self: self.env.user.company_id)
    employee_line_ids = fields.One2many('hr.loan.auto.employee.line', 'config_id',
                                        string="Employees",
                                        help="Employees for automatic loan generation")
    installment = fields.Integer(string="Default No Of Installments", default=1,
                                 help="Default number of installments for the generated loans")

    employee_count = fields.Integer(compute='_compute_employee_count', string="Employees")
    log_count = fields.Integer(compute='_compute_log_count', string="Logs")
    loan_count = fields.Integer(compute='_compute_loan_count', string="Loans")
    batch_count = fields.Integer(compute='_compute_batch_count', string="Batches")
    total_amount = fields.Float(compute='_compute_total_amount', string="Total Amount",
                                help="Total loan amount for all active employees")

    @api.constrains('execution_day')
    def _check_execution_day(self):
        """Validate execution day is between 1-28"""
        for config in self:
            if config.execution_day < 1 or config.execution_day > 28:
                raise ValidationError(_("Execution day must be between 1 and 28"))

    @api.depends('employee_line_ids', 'employee_line_ids.loan_amount', 'employee_line_ids.active')
    def _compute_total_amount(self):
        """Compute total loan amount for all active employees"""
        for config in self:
            total = sum(line.loan_amount for line in config.employee_line_ids if line.active)
            config.total_amount = total

    @api.depends('employee_line_ids')
    def _compute_employee_count(self):
        """Compute the number of employees in this configuration"""
        for config in self:
            config.employee_count = len(config.employee_line_ids)

    @api.depends()
    def _compute_log_count(self):
        """Compute the number of execution logs for this configuration"""
        for config in self:
            config.log_count = self.env['hr.loan.auto.log'].search_count([
                ('config_id', '=', config.id)
            ])

    @api.depends()
    def _compute_loan_count(self):
        """Compute the number of loans generated by this configuration"""
        for config in self:
            config.loan_count = self.env['hr.loan'].search_count([
                ('auto_config_id', '=', config.id),
                ('is_auto_generated', '=', True)
            ])

    @api.depends()
    def _compute_batch_count(self):
        """Compute the number of batches generated by this configuration"""
        for config in self:
            config.batch_count = self.env['hr.loan.batch'].search_count([
                ('auto_config_id', '=', config.id),
                ('execution_day', '=', config.execution_day)
            ])

    def action_view_batches(self):
        """View batches generated by this configuration"""
        self.ensure_one()
        return {
            'name': _('Đợt ứng lương - %s') % self.name,
            'domain': [('auto_config_id', '=', self.id)],
            'res_model': 'hr.loan.batch',
            'type': 'ir.actions.act_window',
            'view_mode': 'tree,form',
            'context': {'default_auto_config_id': self.id}
        }

class HrLoanAutoEmployeeLine(models.Model):
    """Employee lines for automatic loan configuration"""
    _name = 'hr.loan.auto.employee.line'
    _description = "Automatic Loan Employee Line"

    config_id = fields.Many2one('hr.loan.auto.config', string="Configuration",
                                required=True, ondelete='cascade',
                                help="Reference to the configuration")
    employee_id = fields.Many2one('hr.employee', string="Employee", required=True,
                                  help="Employee to generate loans for")
    loan_amount = fields.Float(string="Loan Amount", required=True,
                               help="Amount to be generated for this employee")
    active = fields.Boolean(string="Active", default=True,
                            help="Whether automatic loan generation is active for this employee")
    notes = fields.Text(string="Notes", help="Additional notes")

    _sql_constraints = [
        ('unique_employee_config', 'UNIQUE(config_id, employee_id)',
         'Each employee can only be added once to a configuration!'),
    ]


class HrLoanAutoLog(models.Model):
    """Log of automatic loan generation executions"""
    _name = 'hr.loan.auto.log'
    _description = "Automatic Loan Generation Log"
    _order = "execution_date desc"

    name = fields.Char(string="Reference", default="New", readonly=True)
    execution_date = fields.Datetime(string="Execution Date", readonly=True,
                                     default=fields.Datetime.now,
                                     help="Date and time when the automatic generation ran")
    config_id = fields.Many2one('hr.loan.auto.config', string="Configuration",
                                readonly=True,
                                help="Configuration that was executed")
    batch_id = fields.Many2one('hr.loan.batch', string="Batch Created",
                               readonly=True,
                               help="Batch created during this execution")
    loan_count = fields.Integer(string="Loans Created", readonly=True,
                                help="Number of loans created during this run")
    state = fields.Selection([
        ('success', 'Success'),
        ('partial', 'Partial Success'),
        ('failed', 'Failed')
    ], string="State", default='success', readonly=True,
        help="Result state of the execution")
    note = fields.Text(string="Execution Notes", readonly=True,
                       help="Details about the execution")

    @api.model
    def create(self, vals):
        """Generate sequence for the log entry"""
        if vals.get('name', 'New') == 'New':
            vals['name'] = self.env['ir.sequence'].next_by_code('hr.loan.auto.log') or 'New'
        return super(HrLoanAutoLog, self).create(vals)


class AutoLoanGeneration(models.Model):
    """Model for the automatic loan generation functionality"""
    _name = 'hr.loan.auto.generation'
    _description = "Automatic Loan Generation"

    @api.model
    def _generate_auto_loans(self):
        """
        Enhanced automatic loan generation with better batch management
        """
        today = (datetime.utcnow() + timedelta(hours=7)).date()
        current_day = today.day

        # Find active configurations with matching execution day
        configs = self.env['hr.loan.auto.config'].search([
            ('active', '=', True),
            ('execution_day', '=', current_day)
        ])

        for config in configs:
            # Check if batch already exists for this config and month
            batch = self.env['hr.loan.batch'].search([
                ('month', '=', str(today.month)),
                ('year', '=', today.year),
                ('company_id', '=', config.company_id.id),
                ('auto_config_id', '=', config.id),
                ('execution_day', '=', config.execution_day),
                ('state', '!=', 'cancelled')
            ], limit=1)

            if not batch:
                # Create new batch with execution date
                batch = self.env['hr.loan.batch'].create({
                    'month': str(today.month),
                    'year': today.year,
                    'company_id': config.company_id.id,
                    'auto_config_id': config.id,
                    'execution_date': today,
                    'execution_day': config.execution_day,
                })

            log_vals = {
                'config_id': config.id,
                'batch_id': batch.id,
                'execution_date': fields.Datetime.now(),
                'loan_count': 0,
                'state': 'success',
                'note': f'Batch created on execution day {current_day}',
            }

            created_loans = 0
            error_notes = []

            # Get active employee lines from this config
            employee_lines = self.env['hr.loan.auto.employee.line'].search([
                ('config_id', '=', config.id),
                ('active', '=', True)
            ])

            for line in employee_lines:
                employee = line.employee_id

                # Enhanced duplicate check - consider current batch
                existing_loan = self.env['hr.loan'].search_count([
                    ('employee_id', '=', employee.id),
                    ('state', 'in', ['approve', 'waiting_approval_1']),
                    ('balance_amount', '!=', 0),
                    '|',
                    ('auto_config_id', '=', config.id),
                    ('batch_id', '=', batch.id)
                ])

                if existing_loan:
                    error_notes.append(
                        f"Employee {employee.name} already has a pending loan. Skipped.")
                    continue

                # Create the loan with enhanced information
                try:
                    loan_vals = {
                        'employee_id': employee.id,
                        'loan_amount': line.loan_amount,
                        'installment': config.installment,
                        'payment_date': today,
                        'is_auto_generated': True,
                        'auto_config_id': config.id,
                        'batch_id': batch.id,
                        'state': 'draft',
                    }

                    loan = self.env['hr.loan'].create(loan_vals)

                    # Compute installments
                    loan.action_compute_installment()

                    # Auto-submit for approval
                    loan.action_submit()

                    created_loans += 1

                except Exception as e:
                    error_notes.append(
                        f"Failed to create loan for {employee.name}: {str(e)}")

            # Update log with results
            log_vals['loan_count'] = created_loans
            if error_notes:
                log_vals['note'] = f"Batch created on execution day {current_day}.\n" + '\n'.join(error_notes)
                if created_loans == 0:
                    log_vals['state'] = 'failed'
                    batch.action_cancel()
                else:
                    log_vals['state'] = 'partial'
                    batch.action_confirm()
            else:
                log_vals[
                    'note'] = f"Successfully created {created_loans} loans on execution day {current_day} in batch {batch.name}."
                batch.action_confirm()

            # Create the log entry
            log = self.env['hr.loan.auto.log'].create(log_vals)

            # Update created loans with log reference
            if created_loans > 0:
                loans = self.env['hr.loan'].search([
                    ('is_auto_generated', '=', True),
                    ('auto_config_id', '=', config.id),
                    ('batch_id', '=', batch.id),
                    ('auto_log_id', '=', False)
                ])
                loans.write({'auto_log_id': log.id})

        return True

    @api.model
    def _check_missed_executions(self):
        """
        Check for missed executions due to system downtime
        Run this as a separate scheduled action daily
        """
        today = fields.Date.today()

        # Check last 7 days for missed executions
        for days_back in range(1, 8):
            check_date = today - relativedelta(days=days_back)
            check_day = check_date.day

            # Skip if it's today (handled by main function)
            if check_date == today:
                continue

            # Find configs that should have run on check_date
            configs = self.env['hr.loan.auto.config'].search([
                ('active', '=', True),
                ('execution_day', '=', check_day)
            ])

            for config in configs:
                # Check if batch was already created for that date
                existing_batch = self.env['hr.loan.batch'].search([
                    ('month', '=', str(check_date.month)),
                    ('year', '=', check_date.year),
                    ('company_id', '=', config.company_id.id),
                    ('auto_config_id', '=', config.id),
                    ('execution_date', '=', check_date),
                ], limit=1)

                if not existing_batch:
                    # Create missed execution log
                    self.env['hr.loan.auto.log'].create({
                        'config_id': config.id,
                        'execution_date': fields.Datetime.now(),
                        'loan_count': 0,
                        'state': 'failed',
                        'note': f'Missed execution for date {check_date} (execution day {check_day}). System may have been down.',
                    })


# Wizard for manual batch generation
class HrLoanAutoGenerationWizard(models.TransientModel):
    """Wizard for manual loan generation"""
    _name = 'hr.loan.auto.generation.wizard'
    _description = "Manual Loan Generation Wizard"

    config_id = fields.Many2one('hr.loan.auto.config', string="Configuration", required=True)

    def generate_loans(self):
        """Generate loans manually for the selected configuration"""
        config = self.config_id
        today = fields.Date.today()

        # Create batch
        batch = self.env['hr.loan.batch'].create({
            'month': today.month,
            'year': today.year,
            'company_id': config.company_id.id,
            'auto_config_id': config.id
        })

        created_loans = 0
        error_notes = []

        # Get active employee lines
        employee_lines = self.env['hr.loan.auto.employee.line'].search([
            ('config_id', '=', config.id),
            ('active', '=', True)
        ])

        for line in employee_lines:
            employee = line.employee_id

            # Check existing pending loans
            existing_loan = self.env['hr.loan'].search_count([
                ('employee_id', '=', employee.id),
                ('state', 'in', ['approve', 'waiting_approval_1']),
                ('balance_amount', '!=', 0),
            ])

            if existing_loan:
                error_notes.append(f"Employee {employee.name} already has a pending loan. Skipped.")
                continue

            try:
                loan_vals = {
                    'employee_id': employee.id,
                    'loan_amount': line.loan_amount,
                    'installment': config.installment,
                    'payment_date': today,
                    'is_auto_generated': True,
                    'auto_config_id': config.id,
                    'batch_id': batch.id,
                    'state': 'draft',
                }

                loan = self.env['hr.loan'].create(loan_vals)
                loan.action_compute_installment()
                loan.action_submit()
                created_loans += 1

            except Exception as e:
                error_notes.append(f"Failed to create loan for {employee.name}: {str(e)}")

        # Create log
        log_vals = {
            'config_id': config.id,
            'batch_id': batch.id,
            'execution_date': fields.Datetime.now(),
            'loan_count': created_loans,
            'state': 'success' if created_loans > 0 and not error_notes else ('partial' if created_loans > 0 else 'failed'),
            'note': f"Manual generation: {created_loans} loans created." + (f"\nErrors: {'; '.join(error_notes)}" if error_notes else "")
        }

        log = self.env['hr.loan.auto.log'].create(log_vals)

        # Update loans with log reference
        if created_loans > 0:
            loans = self.env['hr.loan'].search([
                ('batch_id', '=', batch.id),
                ('auto_log_id', '=', False)
            ])
            loans.write({'auto_log_id': log.id})
            batch.action_confirm()
        else:
            batch.action_cancel()

        return {
            'type': 'ir.actions.act_window',
            'res_model': 'hr.loan.batch',
            'res_id': batch.id,
            'view_mode': 'form',
            'target': 'current',
        }